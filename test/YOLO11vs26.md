# 📊 YOLO11 vs YOLO26 비교 실험 버전 요약

## v1.0: 고성능 객체 추적 (Tracking Mode)

> **목표:** 실제 서비스 환경과 유사하게 객체의 ID를 유지하며 추적하는 성능을 비교.

**ByteTrack 알고리즘**을 사용하여 사람에게 고유 ID를 부여해 추적(Tracking).

* **메모리 최적화:** GPU 메모리 효율을 위해 YOLO 11과 26 모델(Detection/Pose)을 루프 밖에서 **한 번만 로드**.
* **결과물:** 각 모델의 실시간 추론 속도(FPS)와 추적 결과를 **2x2 그리드 형태의 비디오**로 병합하여 저장.

### 🛠️ 사용된 기술: ByteTrack

1. **탐지 후 연결 (Tracking-by-Detection)**
* YOLO가 매 프레임 사람을 먼저 탐지(Detection).
* 트래커는 이전 프레임의 위치 정보를 바탕으로 현재 탐지된 객체와 매칭하여 선을 잇듯이 연결.


2. **낮은 점수의 박스 재활용 (Low Score Association)**
* 일반적인 트래커는 신뢰도(Confidence)가 낮은 객체를 버립니다.
* **ByteTrack**은 점수가 낮은 박스도 즉시 버리지 않고 재검토하여, 가려짐(Occlusion)이나 흐릿한 객체에 대해서도 **ID 끊김 없이 강인한 추적**을 수행.


3. **가벼운 연산 (CPU 친화적)**
* 무거운 딥러닝 특징(Feature) 추출 대신, 박스의 겹치는 영역(IoU) 기반 연산을 주로 사용.
* BoT-SORT 등 다른 알고리즘 대비 **CPU 부하가 적고 처리 속도가 빠릅니다.**



---

## v1.1: 순수 추론 속도 측정 (Detection Mode)

> **목표:** 추적 알고리즘의 부하를 제거하고, 모델 본연의 최대 하드웨어 추론 속도(FPS)를 측정.

속도 저하의 원인이었던 객체 추적(Tracking) 기능을 제거하고, **순수 탐지(Detection)** 모드로 전환하여 벤치마킹을 수행.

* **핵심 변경:** `model.track()` 대신 **`model.predict()`**를 사용하여 ID 부여 과정을 생략했습니다.
* **성능:** 트래킹 오버헤드가 사라져 **FPS 처리 속도가 극대화**됩니다.
* **결과물:** 탐지된 바운딩 박스(BBox), 키포인트(Keypoints), 그리고 최대 FPS 정보를 포함한 **2x2 비교 영상**을 생성.